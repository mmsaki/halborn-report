## tag::1[]
== H-1 Uncontrolled Resource Consumption
Tags: `runtime`, Weakness: {url-cwe}400.html[CWE-400], CVE ID: {url-nist}CVE-2022-41723[CVE-2022-41723], GHSA ID: {url-ghsa}GHSA-vvpx-j8f3-3w6h[GHSA-vvpx-j8f3-3w6h]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L247
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=247]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

A maliciously crafted HTTP/2 stream could cause excessive CPU consumption in the HPACK decoder, sufficient to cause a denial of service from a small number of small requests.

## end::1[]
## tag::2[]
== H-2 golang.org/x/crypto/ssh Denial of service via crafted Signer
Tags: `runtime`, Weakness: {url-cwe}327.html[CWE-327], CVE ID: {url-nist}CVE-2022-27191[CVE-2022-27191], GHSA ID: {url-ghsa}GHSA-8c26-wmh5-6g9v[GHSA-8c26-wmh5-6g9v]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L245
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=245]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

The golang.org/x/crypto/ssh package before 0.0.0-20220314234659-1baeb1ce4c0b for Go allows an attacker to crash a server in certain circumstances involving AddHostKey.

## end::2[]
## tag::3[]
== H-3 golang.org/x/net/http2 Denial of Service vulnerability
Tags: `runtime`, CVE ID: {url-nist}CVE-2022-27664[CVE-2022-27664], GHSA ID: {url-ghsa}GHSA-69cg-p879-7622[GHSA-69cg-p879-7622]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L247
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=247]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

In net/http in Go before 1.18.6 and 1.19.x before 1.19.1, attackers can cause a denial of service because an HTTP/2 connection can hang during closing if shutdown were preempted by a fatal error.

## end::3[]
## tag::4[]
== H-4 golang.org/x/text/language Denial of service via crafted Accept-Language header
Tags: `runtime`, Weakness: {url-cwe}772.html[CWE-772], CVE ID: {url-nist}CVE-2022-32149[CVE-2022-32149], GHSA ID: {url-ghsa}GHSA-69ch-w2m2-3vjp[GHSA-69ch-w2m2-3vjp]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L251
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=251]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

The BCP 47 tag parser has quadratic time complexity due to inherent aspects of its design. Since the parser is, by design, exposed to untrusted user input, this can be leveraged to force a program to consume significant time parsing Accept-Language headers. The parser cannot be easily rewritten to fix this behavior for various reasons. Instead the solution implemented in this CL is to limit the total complexity of tags passed into ParseAcceptLanguage by limiting the number of dashes in the string to 1000. This should be more than enough for the majority of real world use cases, where the number of tags being sent is likely to be in the single digits.

=== Specific Go Packages Affected
golang.org/x/text/language

## end::4[]
## tag::5[]
== H-5 golang.org/x/net/http2/h2c vulnerable to request smuggling attack
Tags: `runtime`, Weakness: {url-cwe}444.html[CWE-444], CVE ID: {url-nist}CVE-2022-41721[CVE-2022-41721], GHSA ID: {url-ghsa}GHSA-fxg5-wq6x-vr4w[GHSA-fxg5-wq6x-vr4w]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L247
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=247]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

A request smuggling attack is possible when using MaxBytesHandler. When using MaxBytesHandler, the body of an HTTP request is not fully consumed. When the server attempts to read HTTP2 frames from the connection, it will instead be reading the body of the HTTP request, which could be attacker-manipulated to represent arbitrary HTTP2 requests.

=== Specific Go Packages Affected
golang.org/x/net/http2/h2c

## end::5[]
## tag::6[]
== H-6 Opencontainers runc Incorrect Authorization vulnerability
Tags: `runtime`, Weakness: {url-cwe}706.html[CWE-706], CVE ID: {url-nist}CVE-2023-27561[CVE-2023-27561], GHSA ID: {url-ghsa}GHSA-vpvm-3wq2-2wvm[GHSA-vpvm-3wq2-2wvm]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L189
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=189]
++++
----

=== CVSS Score: 7.0/10
.CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Local
| Attack complexity | High
| Privileges required | Low
| User interaction | None
| Scope | Unchange
| Confidentiality | High
| Integrity | High
| Availability  | High
|===

runc 1.0.0-rc95 through 1.1.4 has Incorrect Access Control leading to Escalation of Privileges, related to `libcontainer/rootfs_linux.go`. To exploit this, an attacker must be able to spawn two containers with custom volume-mount configurations, and be able to run custom images. NOTE: this issue exists because of a CVE-2019-19921 regression.

## end::6[]
## tag::7[]
== H-7 Docker Swarm encrypted overlay network may be unauthenticated
Tags: `runtime`, Weakness: {url-cwe}420.html[CWE-420], {url-cwe}636.html[CWE-636], CVE ID: {url-nist}CVE-2023-28840[CVE-2023-28840], GHSA ID: {url-ghsa}GHSA-232p-vwff-86mp[GHSA-232p-vwff-86mp]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L84
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=84]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:L
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | High
| Privileges required | None
| User interaction | None
| Scope | Changed
| Confidentiality | High
| Integrity | None
| Availability  | Low
|===

https://mobyproject.org/[Moby] is an open source container framework developed by Docker Inc. that is distributed as Docker, Mirantis Container Runtime, and various other downstream projects/products. The Moby daemon component (`dockerd`), which is developed as https://github.com/moby/moby[moby/moby] is commonly referred to as *Docker*.

Swarm Mode, which is compiled in and delivered by default in `dockerd` and is thus present in most major Moby downstreams, is a simple, built-in container orchestrator that is implemented through a combination of https://github.com/moby/swarmkit[SwarmKit] and supporting network code.

The `overlay` network driver is a core feature of Swarm Mode, providing isolated virtual LANs that allow communication between containers and services across the cluster. This driver is an implementation/user of https://en.wikipedia.org/wiki/Virtual_Extensible_LAN[VXLAN], which encapsulates link-layer (Ethernet) frames in UDP datagrams that tag the frame with a VXLAN Network ID (VNI) that identifies the originating overlay network. In addition, the overlay network driver supports an optional, off-by-default encrypted mode, which is especially useful when VXLAN packets traverses an untrusted network between nodes.

Encrypted overlay networks function by encapsulating the VXLAN datagrams through the use of the https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload[IPsec Encapsulating Security Payload] protocol in https://en.wikipedia.org/wiki/IPsec#Transport_mode[Transport mode]. By deploying IPSec encapsulation, encrypted overlay networks gain the additional properties of source authentication through cryptographic proof, data integrity through check-summing, and confidentiality through encryption.

When setting an endpoint up on an encrypted overlay network, Moby installs three https://www.netfilter.org/projects/iptables/index.html[iptables] (Linux kernel firewall) rules that enforce both incoming and outgoing IPSec. These rules rely on the `u32` iptables extension provided by the `xt_u32` kernel module to directly filter on a VXLAN packet's VNI field, so that IPSec guarantees can be enforced on encrypted overlay networks without interfering with other overlay networks or other users of VXLAN.

https://github.com/moby/libnetwork/blob/d9fae4c73daf76c3b0f77e14b45b8bf612ba764d/drivers/overlay/encryption.go#L230-L234[Two iptables rules] serve to filter incoming VXLAN datagrams with a VNI that corresponds to an encrypted network and discards unencrypted datagrams. The rules are appended to the end of the `INPUT` filter chain, following any rules that have been previously set by the system administrator. Administrator-set rules take precedence over the rules Moby sets to discard unencrypted VXLAN datagrams, which can potentially admit unencrypted datagrams that should have been discarded.

On Red Hat Enterprise Linux and derivatives such as CentOS and Rocky, the `xt_u32` module has been:
* https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.3_release_notes/rhel-8-3-0-release#technology-preview_networking[moved to the kernel-modules-extra package and no longer installed by default in RHEL 8.3]
* https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/8.6_release_notes/deprecated_functionality#deprecated-functionality_networking[officially deprecated in RHEL 8.6]
* https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/assembly_networking_considerations-in-adopting-rhel-9#ref_firewall-networking_assembly_networking[removed completely in RHEL 9]

These rules are not created when `xt_u32` is unavailable, even though the container is still attached to the network.

=== Impact
Encrypted overlay networks on affected configurations silently accept cleartext VXLAN datagrams that are tagged with the VNI of an encrypted overlay network. As a result, it is possible to inject arbitrary Ethernet frames into the encrypted overlay network by encapsulating them in VXLAN datagrams.

The injection of arbitrary Ethernet frames can enable a Denial of Service attack. A sophisticated attacker may be able to establish a UDP or TCP connection by way of the container’s outbound gateway that would otherwise be blocked by a stateful firewall, or carry out other escalations beyond simple injection by smuggling packets into the overlay network.

=== Patches
Patches are available in Moby releases 23.0.3, and 20.10.24. As Mirantis Container Runtime's 20.10 releases are numbered differently, users of that platform should update to 20.10.16.

=== Workarounds
* Close the VXLAN port (by default, UDP port 4789) to incoming traffic at the Internet boundary (see https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw[GHSA-vwm3-crmr-xfxw]) to prevent all VXLAN packet injection.
* Ensure that the `xt_u32` kernel module is available on all nodes of the Swarm cluster.

=== Background
* https://github.com/moby/moby/issues/43382[#43382] partially discussed this concern, but did not consider the security implications.
* Mirantis FIELD-5788 essentially duplicates https://github.com/moby/moby/issues/43382[#43382], and was created six months earlier; it similarly overlooked the security implications.
* https://github.com/moby/moby/pull/45118[#45118] is the ancestor of the final patches, and was where the security implications were discovered.

=== Related
* https://github.com/moby/moby/security/advisories/GHSA-33pg-m6jh-5237[CVE-2023-28841: Encrypted overlay network traffic may be unencrypted]
* https://github.com/moby/moby/security/advisories/GHSA-6wrf-mxfj-pf5p[CVE-2023-28842: Encrypted overlay network with a single endpoint is unauthenticated]
* https://github.com/moby/moby/security/advisories/GHSA-vwm3-crmr-xfxw[GHSA-vwm3-crmr-xfxw: The Swarm VXLAN port may be exposed to attack due to ambiguous documentation]
* https://github.com/moby/libnetwork/security/advisories/GHSA-gvm4-2qqg-m333[GHSA-gvm4-2qqg-m333: Security issues in encrypted overlay networks] (libnetwork)

## end::7[]
## tag::8[]
== H-8 gopkg.in/yaml.v3 Denial of Service
Tags: `runtime`, Weakness: {url-cwe}502.html[CWE-502], CVE ID: {url-nist}CVE-2022-28948[CVE-2022-28948], GHSA ID: {url-ghsa}GHSA-hp87-p4gw-j4gq[GHSA-hp87-p4gw-j4gq]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L255
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=255]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

An issue in the Unmarshal function in Go-Yaml v3 can cause a program to panic when attempting to deserialize invalid input.

## end::8[]
## tag::9[]
== H-9 HTTP/2 rapid reset can cause excessive work in net/http
Tags: `runtime`, Weakness: {url-cwe}400.html[CWE-400], {url-cwe}770.html[CWE-770], CVE ID: {url-nist}CVE-2023-39325[CVE-2023-39325], GHSA ID: {url-ghsa}GHSA-4374-p667-p6c8[GHSA-4374-p667-p6c8]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L247
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=247]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

A malicious HTTP/2 client which rapidly creates requests and immediately resets them can cause excessive server resource consumption. While the total number of requests is bounded by the http2.Server.MaxConcurrentStreams setting, resetting an in-progress request allows the attacker to create a new request while the existing one is still executing. 

With the fix applied, HTTP/2 servers now bound the number of simultaneously executing handler goroutines to the stream concurrency limit (MaxConcurrentStreams). New requests arriving when at the limit (which can only happen after the client has reset an existing, in-flight request) will be queued until a handler exits. If the request queue grows too large, the server will terminate the connection. 

This issue is also fixed in golang.org/x/net/http2 for users manually configuring HTTP/2.

The default stream concurrency limit is 250 streams (requests) per HTTP/2 connection. This value may be adjusted using the golang.org/x/net/http2 package; see the Server.MaxConcurrentStreams setting and the ConfigureServer function.

## end::9[]
## tag::10[]
== H-10 gRPC-Go HTTP/2 Rapid Reset vulnerability
Tags: `runtime`, GHSA ID: {url-ghsa}GHSA-m425-mq94-257g[GHSA-m425-mq94-257g]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L28
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=28]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

=== Impact
In affected releases of gRPC-Go, it is possible for an attacker to send HTTP/2 requests, cancel them, and send subsequent requests, which is valid by the HTTP/2 protocol, but would cause the gRPC-Go server to launch more concurrent method handlers than the configured maximum stream limit.

=== Patches
This vulnerability was addressed by #6703 and has been included in patch releases: 1.56.3, 1.57.1, 1.58.3.  It is also included in the latest release, 1.59.0.

Along with applying the patch, users should also ensure they are using the `grpc.MaxConcurrentStreams` server option to apply a limit to the server's resources used for any single connection.

=== Workarounds
None.

=== References
#6703


## end::10[]
## tag::11[]
== H-11 runc vulnerable to container breakout through process.cwd trickery and leaked fds
Tags: `runtime`, Weakness: {url-cwe}403.html[CWE-403], {url-cwe}668.html[CWE-668], CVE ID: {url-nist}CVE-2024-21626[CVE-2024-21626], GHSA ID: {url-ghsa}GHSA-xr7r-f8xq-vfvv[GHSA-xr7r-f8xq-vfvv]

.File {url-repo}{url-blob}HalbornCTF_Golang_Cosmos/go.mod#L189
[source,go]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Golang_Cosmos/go.mod[lines=189]
++++
----

=== CVSS Score: 8.6/10
.CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Local
| Attack complexity | Low
| Privileges required | None
| User interaction | Required
| Scope | Changed
| Confidentiality | High
| Integrity | High
| Availability  | High
|===

=== Impact

In runc 1.1.11 and earlier, due to an internal file descriptor leak, an attacker could cause a newly-spawned container process (from `runc exec`) to have a working directory in the host filesystem namespace, allowing for a container escape by giving access to the host filesystem ("attack 2"). The same attack could be used by a malicious image to allow a container process to gain access to the host filesystem through `runc run` ("attack 1"). Variants of attacks 1 and 2 could be also be used to overwrite semi-arbitrary host binaries, allowing for complete container escapes ("attack 3a" and "attack 3b").

Strictly speaking, while attack 3a is the most severe from a CVSS perspective, attacks 2 and 3b are arguably more dangerous in practice because they allow for a breakout from inside a container as opposed to requiring a user execute a malicious image. The reason attacks 1 and 3a are scored higher is because being able to socially engineer users is treated as a given for UI:R vectors, despite attacks 2 and 3b requiring far more minimal user interaction (just reasonable `runc exec` operations on a container the attacker has access to). In any case, all four attacks can lead to full control of the host system.

=== Attack 1: `process.cwd` "mis-configuration"

In runc 1.1.11 and earlier, several file descriptors were inadvertently leaked internally within runc into `runc init`, including a handle to the host's `/sys/fs/cgroup` (this leak was added in v1.0.0-rc93). If the container was configured to have `process.cwd` set to `/proc/self/fd/7/` (the actual fd can change depending on file opening order in `runc`), the resulting pid1 process will have a working directory in the host mount namespace and thus the spawned process can access the entire host filesystem. This alone is not an exploit against runc, however a malicious image could make any innocuous-looking non-`/` path a symlink to `/proc/self/fd/7/` and thus trick a user into starting a container whose binary has access to the host filesystem.

Furthermore, prior to runc 1.1.12, runc also did not verify that the final working directory was inside the container's mount namespace after calling `chdir(2)` (as we have already joined the container namespace, it was incorrectly assumed there would be no way to chdir outside the container after `pivot_root(2)`).

The CVSS score for this attack is CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N (8.2, high severity).

Note that this attack requires a privileged user to be tricked into running a malicious container image. It should be noted that when using higher-level runtimes (such as Docker or Kubernetes), this exploit can be considered critical as it can be done remotely by anyone with the rights to start a container image (and can be exploited from within Dockerfiles using `ONBUILD` in the case of Docker).

=== Attack 2: `runc exec` container breakout

(This is a modification of attack 1, constructed to allow for a process inside a container to break out.)

The same fd leak and lack of verification of the working directory in attack 1 also apply to `runc exec`. If a malicious process inside the container knows that some administrative process will call `runc exec` with the `--cwd` argument and a given path, in most cases they can replace that path with a symlink to `/proc/self/fd/7/`. Once the container process has executed the container binary, `PR_SET_DUMPABLE` protections no longer apply and the attacker can open `/proc/$exec_pid/cwd` to get access to the host filesystem.

`runc exec` defaults to a cwd of `/` (which cannot be replaced with a symlink), so this attack depends on the attacker getting a user (or some administrative process) to use `--cwd` and figuring out what path the target working directory is. Note that if the target working directory is a parent of the program binary being executed, the attacker might be unable to replace the path with a symlink (the `execve` will fail in most cases, unless the host filesystem layout specifically matches the container layout in specific ways and the attacker knows which binary the `runc exec` is executing).

The CVSS score for this attack is CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N (7.2, high severity).

=== Attacks 3a and 3b: `process.args` host binary overwrite attack

(These are modifications of attacks 1 and 2, constructed to overwrite a host binary by using `execve` to bring a magic-link reference into the container.)

Attacks 1 and 2 can be adapted to overwrite a host binary by using a path like `/proc/self/fd/7/../../../bin/bash` as the `process.args` binary argument, causing a host binary to be executed by a container process. The `/proc/$pid/exe` handle can then be used to overwrite the host binary, as seen in CVE-2019-5736 (note that the same `#!` trick can be used to avoid detection as an attacker). As the overwritten binary could be something like `/bin/bash`, as soon as a privileged user executes the target binary on the host, the attacker can pivot to gain full access to the host.

For the purposes of CVSS scoring:

* Attack 3a is attack 1 but adapted to overwrite a host binary, where a malicious image is set up to execute `/proc/self/fd/7/../../../bin/bash` and run a shell script that overwrites `/proc/self/exe`, overwriting the host copy of `/bin/bash`. The CVSS score for this attack is CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H (8.6, high severity).
* Attack 3b is attack 2 but adapted to overwrite a host binary, where the malicious container process overwrites all of the possible `runc exec` target binaries inside the container (such as `/bin/bash`) such that a host target binary is executed and then the container process opens `/proc/$pid/exe` to get access to the host binary and overwrite it. The CVSS score for this attack is CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H (8.2, high severity).

As mentioned in attack 1, while 3b is scored lower it is more dangerous in practice as it doesn't require a user to run a malicious image.

=== Patches
runc 1.1.12 has been released, and includes patches for this issue. Note that there are four separate fixes applied:

* Checking that the working directory is actually inside the container by checking whether `os.Getwd` returns `ENOENT` (Linux provides a way of detecting if cwd is outside the current namespace root). This explicitly blocks runc from executing a container process when inside a non-container path and thus eliminates attacks 1 and 2 even in the case of fd leaks.
* Close all internal runc file descriptors in the final stage of `runc init`, right before `execve`. This ensures that internal file descriptors cannot be used as an argument to `execve` and thus eliminates attacks 3a and 3b, even in the case of fd leaks. This requires hooking into some Go runtime internals to make sure we don't close critical Go internal file descriptors.
* Fixing the specific fd leaks that made these bug exploitable (mark `/sys/fs/cgroup` as `O_CLOEXEC` and backport a fix for some `*os.File` leaks).
* In order to protect against future `runc init` file descriptor leaks, mark all non-stdio files as `O_CLOEXEC` before executing `runc init`.

=== Other Runtimes

We have discovered that several other container runtimes are either potentially vulnerable to similar attacks, or do not have sufficient protection against attacks of this nature. We recommend other container runtime authors look at #Patches[our patches] and make sure they at least add a `getcwd() != ENOENT` check as well as consider whether `close_range(3, UINT_MAX, CLOSE_RANGE_CLOEXEC)` before executing their equivalent of `runc init` is appropriate.

 * crun 1.12 does not leak any useful file descriptors into the `runc init`-equivalent process (so this attack is _not exploitable_ as far as we can tell), but no care is taken to make sure all non-stdio files are `O_CLOEXEC` and there is no check after `chdir(2)` to ensure the working directory is inside the container. If a file descriptor happened to be leaked in the future, this could be exploitable. In addition, any file descriptors passed to `crun` are not closed until the container process is executed, meaning that easily-overlooked programming errors by users of `crun` can lead to these attacks becoming exploitable.
 * youki 0.3.1 does not leak any useful file descriptors into the `runc init`-equivalent process (so this attack is _not exploitable_ as far as we can tell) however this appears to be pure luck. `youki` does leak a directory file descriptor from the host mount namespace, but it just so happens that the directory is the rootfs of the container (which then gets `pivot_root`'d into and so ends up as a in-root path thanks to `chroot_fs_refs`). In addition, no care is taken to make sure all non-stdio files are `O_CLOEXEC` and there is no check after `chdir(2)` to ensure the working directory is inside the container. If a file descriptor happened to be leaked in the future, this could be exploitable. In addition, any file descriptors passed to `youki` are not closed until the container process is executed, meaning that easily-overlooked programming errors by users of `youki` can lead to these attacks becoming exploitable.
 * LXC 5.0.3 does not appear to leak any useful file descriptors, and they have comments noting the importance of not leaking file descriptors in `lxc-attach`. However, they don't seem to have any proactive protection against file descriptor leaks at the point of `chdir` such as using `close_range(...)` (they do have RAII-like `__do_fclose` closers but those don't necessarily stop all leaks in this context) nor do they have any check after `chdir(2)` to ensure the working directory is inside the container. Unfortunately it seems they cannot use `CLOSE_RANGE_CLOEXEC` because they don't need to re-exec themselves.

=== Workarounds
For attacks 1 and 2, only permit containers (and `runc exec`) to use a `process.cwd` of `/`. It is not possible for `/` to be replaced with a symlink (the path is resolved from within the container's mount namespace, and you cannot change the root of a mount namespace or an fs root to a symlink).

For attacks 1 and 3a, only permit users to run trusted images.

For attack 3b, there is no practical workaround other than never using `runc exec` because any binary you try to execute with `runc exec` could end up being a malicious binary target.

=== See Also
* https://www.cve.org/CVERecord?id=CVE-2024-21626
* https://github.com/opencontainers/runc/releases/tag/v1.1.12
* The runc 1.1.12 merge commit https://github.com/opencontainers/runc/commit/a9833ff391a71b30069a6c3f816db113379a4346, which contains the following security patches:
  * https://github.com/opencontainers/runc/commit/506552a88bd3455e80a9b3829568e94ec0160309
  * https://github.com/opencontainers/runc/commit/0994249a5ec4e363bfcf9af58a87a722e9a3a31b
  * https://github.com/opencontainers/runc/commit/fbe3eed1e568a376f371d2ced1b4ac16b7d7adde
  * https://github.com/opencontainers/runc/commit/284ba3057e428f8d6c7afcc3b0ac752e525957df
  * https://github.com/opencontainers/runc/commit/b6633f48a8c970433737b9be5bfe4f25d58a5aa7
  * https://github.com/opencontainers/runc/commit/683ad2ff3b01fb142ece7a8b3829de17150cf688
  * https://github.com/opencontainers/runc/commit/e9665f4d606b64bf9c4652ab2510da368bfbd951

=== Credits

Thanks to Rory McNamara from Snyk for discovering and disclosing the original vulnerability (attack 1) to Docker, @lifubang from acmcoder for discovering how to adapt the attack to overwrite host binaries (attack 3a), and Aleksa Sarai from SUSE for discovering how to adapt the attacks to work as container breakouts using `runc exec` (attacks 2 and 3b).

## end::11[]
## tag::12[]
== H-12 Memory access due to code generation flaw in Cranelift module
Tags: `runtime`, Weakness: {url-cwe}125.html[CWE-125], {url-cwe}788.html[CWE-788], CVE ID: {url-nist}CVE-2021-32629[CVE-2021-32629], GHSA ID: {url-ghsa}GHSA-hpqh-2wqx-7qp5[GHSA-hpqh-2wqx-7qp5]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L901
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=900..904]
++++
----

=== CVSS Score: 7.2/10
.CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N
[%header]
|===
2+| CVSS base metrics
| Attack vector | Local
| Attack complexity | High
| Privileges required | Low
| User interaction | Required
| Scope | Changed
| Confidentiality | High
| Integrity | High
| Availability  | None
|===

There is a bug in 0.73.0 of the Cranelift x64 backend that can create a scenario that could result in a potential sandbox escape in a WebAssembly module.  Users of versions 0.73.0 of Cranelift should upgrade to either 0.73.1 or 0.74 to remediate this vulnerability.  Users of Cranelift prior to 0.73.0 should update to 0.73.1 or 0.74 if they were not using the old default backend.

=== Description

This bug was introduced in the new backend on 2020-09-08 and first included in a release on 2020-09-30, but the new backend was not the default prior to 0.73.0. The recently-released version 0.73.0 with default settings, and prior versions with an explicit build flag to select the new backend, are vulnerable.  The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack, under a specific set of circumstances.  If those circumstances occur, the bug could allow access to memory addresses up to 2GiB before the start of the heap allocated for the WebAssembly module.

If the heap bound is larger than 2GiB, then it would be possible to read memory from a computable range dependent on the size of the heap's bound.  

The impact of this bug is highly dependent on heap implementation; specifically:
* if the heap has bounds checks, and
* does not rely exclusively on guard pages, and 
* the heap bound is 2GiB or smaller 

then this bug cannot be used to reach memory from another WebAssembly module heap.

The impact of the vulnerability is mitigated if there is no memory mapped in the range accessible using this bug, for example, if there is a 2 GiB guard region before the WebAssembly module heap.

The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack when the register allocator reloads a spilled integer value narrower than 64 bits. This interacts poorly with another optimization: the instruction selector elides a 32-to-64-bit zero-extend operator when we know that an instruction producing a 32-bit value actually zeros the upper 32 bits of its destination register. Hence, we rely on these zeroed bits, but the type of the value is still i32, and the spill/reload reconstitutes those bits as the sign extension of the i32’s MSB.

The issue would thus occur when:
* An i32 value is greater than or equal to 0x8000_0000;
* The value is spilled and reloaded by the register allocator due to high register pressure in the program between the value’s definition and its use;
* The value is produced by an instruction that we know to be "special" in that it zeroes the upper 32 bits of its destination: add, sub, mul, and, or;
* The value is then zero-extended to 64 bits;
* The resulting 64-bit value is used.

Under these circumstances there is a potential sandbox escape when the i32 value is a pointer. The usual code emitted for heap accesses zero-extends the WebAssembly heap address, adds it to a 64-bit heap base, and accesses the resulting address. If the zero-extend becomes a sign-extend, the module could reach backward and access memory up to 2GiB before the start of its heap.

This bug was identified by developers at Fastly following a report from Javier Cabrera Arteaga, KTH Royal Institute of Technology, with support from project Trustful of Stiftelsen för Strategisk Forskning.  In addition to supporting the analysis and remediation of this vulnerability, Fastly will publish a related Fastly Security Advisory at https://www.fastly.com/security-advisories[https://www.fastly.com/security-advisories].

In addition to assessing the nature of the code generation bug in Cranelift, we have also determined that under specific circumstances, both Lucet and Wasmtime using this version of Cranelift may be exploitable.

=== General Impact to Lucet

Lucet inherits the heap address computation and bounds-checks of Cranelift, which it uses as its backend code generator. Of particular importance specifically is the address-space layout used by Lucet. In the default configuration for Lucet, only a single module is running, and therefore it is not possible to access memory from another module.

By default, the open source implementation of Lucet uses a maximum heap size of 4 GiB, and an instance slot size of 8 GiB, when invoking an instance from the lucet-wasi command-line tool. These settings are within the range of vulnerability described above, but only a single instance is running, so there is no other instance to read. When embedding the runtime (for example, in a long-running daemon), the default for the heap size as described in the source is 1MB; with this setting, the runtime is not vulnerable.

Lucet allocates its WebAssembly module instances into "instance slots", which are contiguous zones of virtual address space that contain the VM context at the bottom, the WebAssembly heap in the next page after that, a guard region in the middle, and other data at the top: the stack and the globals.

If the instance slot size is less than (max heap) + 2GiB, then the lowest accessible address using the bug will overlap with the prior instance’s heap. If the size of VM context + stack + globals is greater than (4GiB - heap limit), then the highest accessible address using the bug will overlap with this critical data. If neither of these conditions are true, the bug should only result in an access to the prior instance’s guard region.

Generally, if the limit is between 2GiB and 4GiB - ~1MB (depending on stack/global size) and the instance slot size is less than 6GiB, the configuration is vulnerable. If the limit is greater than 4GiB - ~1MB, the configuration is vulnerable regardless of instance slot size. Otherwise, the configuration is not vulnerable.

=== General Impact on Wasmtime

In Wasmtime, the same Cranelift heap address computations and heap types are used as above. The memory layout, however, is slightly different, with different outcomes:
* With the mmap implementation impact is mitigated probabilistically if ASLR is enabled.
* With the pooling allocator, the vulnerability only exists if a memory reservation size lower than the default of 6GB is used.

With the default mmap-based instance memory implementation, Wasmtime uses mmap() to allocate a block of memory large enough for the heap and guard region, as specified in its configuration. If the underlying OS implements ASLR (modern Linux, macOS and Windows do) then this address will be randomized, and the region below it will (probabilistically) be free. Hence, the bug is mitigated probabilistically in the default configuration if ASLR is enabled.

If using the pooling allocator, the vulnerability exists if instance memory size (`memory_reservation_size` in InstanceLimit) is strictly less than 6GiB (4 GiB + 2 GiB of guard pages). The default is 6GiB, so the vulnerability is masked in the default pooling allocator configuration.


## end::12[]
## tag::13[]
== H-13 Overflow in prost-types
Tags: `runtime`, Weakness: {url-cwe}120.html[CWE-120], {url-cwe}190.html[CWE-190], CVE ID: {url-nist}CVE-2021-38192[CVE-2021-38192], GHSA ID: {url-ghsa}GHSA-x4qm-mcjq-v2gf[GHSA-x4qm-mcjq-v2gf]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L4937
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=4936..4940]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

Affected versions of this crate contained a bug in which untrusted input could cause an overflow and panic when converting a Timestamp to SystemTime. It is recommended to upgrade to prost-types v0.8 and switch the usage of From<Timestamp> for SystemTime to TryFrom<Timestamp> for SystemTime.

## end::13[]
## tag::14[]
== H-14 Soundness issue in raw-cpuid
Tags: `runtime`, Weakness: {url-cwe}198.html[CWE-198], {url-cwe}400.html[CWE-400], CVE ID: {url-nist}CVE-2021-26306[CVE-2021-26306], GHSA ID: {url-ghsa}GHSA-hvqc-pc78-x9wh[GHSA-hvqc-pc78-x9wh]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L5154
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=5153..5157]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

VendorInfo::as_string(), SoCVendorBrand::as_string(), and ExtendedFunctionInfo::processor_brand_string() construct byte slices using std::slice::from_raw_parts(), with data coming from #[repr(Rust)] structs. This is always undefined behavior.
This flaw has been fixed in v9.0.0, by making the relevant structs #[repr(C)].

## end::14[]
## tag::15[]
== H-15 Use After Free in lru
Tags: `runtime`, Weakness: {url-cwe}416.html[CWE-416], CVE ID: {url-nist}CVE-2021-45720[CVE-2021-45720], GHSA ID: {url-ghsa}GHSA-v362-2895-h9r2[GHSA-v362-2895-h9r2]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L3247
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=3246..3250]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

Lru crate has two functions for getting an iterator. Both iterators give references to key and value. Calling specific functions, like pop(), will remove and free the value, and but it's still possible to access the reference of value which is already dropped causing use after free.

## end::15[]
## tag::16[]
== H-16 crossbeam-utils Race Condition vulnerability
Tags: `runtime`, Weakness: {url-cwe}362.html[CWE-362], CVE ID: {url-nist}CVE-2022-23639[CVE-2022-23639], GHSA ID: {url-ghsa}GHSA-qc84-gqf4-9926[GHSA-qc84-gqf4-9926]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L1066
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=1065..1069]
++++
----

=== CVSS Score: 8.1/10
.CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | High
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | High
| Integrity | High
| Availability  | High
|===

=== Impact

The affected version of this crate incorrectly assumed that the alignment of `{i,u}64` was always the same as `Atomic{I,U}64`. 

However, the alignment of `{i,u}64` on a 32-bit target can be smaller than `Atomic{I,U}64`.

This can cause the following problems:

- Unaligned memory accesses
- Data race

Crates using `fetch_*` methods with `AtomicCell<{i,u}64>` are affected by this issue.

32-bit targets without `Atomic{I,U}64` and 64-bit targets are not affected by this issue.
32-bit targets with `Atomic{I,U}64` and `{i,u}64` have the same alignment are also not affected by this issue.

The following is a complete list of the builtin targets that may be affected. (last update: nightly-2022-02-11)

- armv7-apple-ios (tier 3)
- armv7s-apple-ios (tier 3)
- i386-apple-ios (tier 3)
- i586-unknown-linux-gnu
- i586-unknown-linux-musl
- i686-apple-darwin (tier 3)
- i686-linux-android
- i686-unknown-freebsd
- i686-unknown-haiku (tier 3)
- i686-unknown-linux-gnu
- i686-unknown-linux-musl
- i686-unknown-netbsd (tier 3)
- i686-unknown-openbsd (tier 3)
- i686-wrs-vxworks (tier 3)

(https://gist.github.com/taiki-e/3c7891e8c5f5e0cbcb44d7396aabfe10[script to get list])

=== Patches

This has been fixed in crossbeam-utils 0.8.7.

Affected 0.8.x releases have been yanked.

=== References

https://github.com/crossbeam-rs/crossbeam/pull/781 

=== License

This advisory is in the public domain.

## end::16[]
## tag::17[]
== H-17 Rust's regex crate vulnerable to regular expression denial of service
Tags: `runtime`, Weakness: {url-cwe}400.html[CWE-400], {url-cwe}1333.html[CWE-1333], CVE ID: {url-nist}CVE-2022-24713[CVE-2022-24713], GHSA ID: {url-ghsa}GHSA-m5pq-gvj9-9vr8[GHSA-m5pq-gvj9-9vr8]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L5261
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=5260..5264]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

> This is a cross-post of [the official security advisory][advisory]. The official advisory contains a signed version with our PGP key, as well.

[advisory]: https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw

The Rust Security Response WG was notified that the `regex` crate did not properly limit the complexity of the regular expressions (regex) it parses. An attacker could use this security issue to perform a denial of service, by sending a specially crafted regex to a service accepting untrusted regexes. No known vulnerability is present when parsing untrusted input with trusted regexes.

This issue has been assigned CVE-2022-24713. The severity of this vulnerability is "high" when the `regex` crate is used to parse untrusted regexes. Other uses of the `regex` crate are not affected by this vulnerability.

=== Overview

The `regex` crate features built-in mitigations to prevent denial of service attacks caused by untrusted regexes, or untrusted input matched by trusted regexes. Those (tunable) mitigations already provide sane defaults to prevent attacks. This guarantee is documented and it's considered part of the crate's API.

Unfortunately a bug was discovered in the mitigations designed to prevent untrusted regexes to take an arbitrary amount of time during parsing, and it's possible to craft regexes that bypass such mitigations. This makes it possible to perform denial of service attacks by sending specially crafted regexes to services accepting user-controlled, untrusted regexes.

=== Affected versions

All versions of the `regex` crate before or equal to 1.5.4 are affected by this issue. The fix is include starting from  `regex` 1.5.5.

=== Mitigations

We recommend everyone accepting user-controlled regexes to upgrade immediately to the latest version of the `regex` crate.

Unfortunately there is no fixed set of problematic regexes, as there are practically infinite regexes that could be crafted to exploit this vulnerability. Because of this, we do not recommend denying known problematic regexes.

=== Acknowledgements

We want to thank Addison Crump for responsibly disclosing this to us according to the https://www.rust-lang.org/policies/security[Rust security policy], and for helping review the fix.

We also want to thank Andrew Gallant for developing the fix, and Pietro Albini for coordinating the disclosure and writing this advisory.

## end::17[]
## tag::18[]
== H-18 Use after free in Wasmtime
Tags: `runtime`, Weakness: {url-cwe}416.html[CWE-416], CVE ID: {url-nist}CVE-2022-24791[CVE-2022-24791], GHSA ID: {url-ghsa}GHSA-gwc9-348x-qwv2[GHSA-gwc9-348x-qwv2]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L8590
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=8589..8593]
++++
----

=== CVSS Score: 8.1/10
.CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | High
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | High
| Integrity | High
| Availability  | High
|===

There is a use after free vulnerability in Wasmtime when both running Wasm that uses `externref`s and enabling https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.epoch_interruption[epoch interruption] in Wasmtime. If you are not explicitly enabling epoch interruption (it is disabled by default) then you are not affected. If you are explicitly disabling the Wasm reference types proposal (it is enabled by default) then you are also not affected.

The use after free is caused by Cranelift failing to emit stack maps when there are safepoints inside cold blocks. Cold blocks occur when epoch interruption is enabled. Cold blocks are emitted at the end of compiled functions, and change the order blocks are emitted versus defined. This reordering accidentally caused Cranelift to skip emitting some stack maps because it expected to emit the stack maps in block definition order, rather than block emission order. When Wasmtime would eventually collect garbage, it would fail to find live references on the stack because of the missing stack maps, think that they were unreferenced garbage, and therefore reclaim them. Then after the collection ended, the Wasm code could use the reclaimed-too-early references, which is a use after free.

This bug was discovered while extending our fuzz targets for `externref`s and GC in Wasmtime. The updated fuzz target thoroughly exercises these code paths and feature combinations now. We have also added a regression test for this bug. Released versions 0.34.2 and 0.35.2, which fix the vulnerability. We recommend all Wasmtime users upgrade to these patched versions. If upgrading is not an option for you at this time, you can avoid the vulnerability by either disabling the Wasm reference types proposal or by disabling epoch interruption if you were previously enabling it.

## end::18[]
## tag::19[]
== H-19 Parser creates invalid uninitialized value
Tags: `runtime`, GHSA ID: {url-ghsa}GHSA-f67m-9j94-qv9j[GHSA-f67m-9j94-qv9j]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L2259
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=2258..2262]
++++
----


Affected versions of this crate called `mem::uninitialized()` in the HTTP1 parser to create values of type `httparse::Header` (from the `httparse` crate).
This is unsound, since `Header` contains references and thus must be non-null.
 
The flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.


## end::19[]
## tag::20[]
== H-20 Use after free in lru crate
Tags: `runtime`, GHSA ID: {url-ghsa}GHSA-qqmc-hwqp-8g2w[GHSA-qqmc-hwqp-8g2w]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L3247
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=3246..3250]
++++
----


Lru crate has use after free vulnerability.

Lru crate has two functions for getting an iterator. Both iterators give
references to key and value. Calling specific functions, like pop(), will remove
and free the value, and but it's still possible to access the reference of value
which is already dropped causing use after free.


## end::20[]
## tag::21[]
== H-21 Data race in `Iter` and `IterMut`
Tags: `runtime`, Weakness: {url-cwe}362.html[CWE-362], GHSA ID: {url-ghsa}GHSA-9hpw-r23r-xgm5[GHSA-9hpw-r23r-xgm5]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L7766
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=7765..7769]
++++
----


In the affected version of this crate, `{Iter, IterMut}::next` used a weaker memory ordering when loading values than what was required, exposing a potential data race
when iterating over a `ThreadLocal`'s values.

Crates using `Iter::next`, or `IterMut::next` are affected by this issue.


## end::21[]
## tag::22[]
== H-22 Wasmtime may have data leakage between instances in the pooling allocator
Tags: `runtime`, Weakness: {url-cwe}212.html[CWE-212], {url-cwe}226.html[CWE-226], CVE ID: {url-nist}CVE-2022-39393[CVE-2022-39393], GHSA ID: {url-ghsa}GHSA-wh6w-3828-g9qf[GHSA-wh6w-3828-g9qf]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L8590
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=8589..8593]
++++
----

=== CVSS Score: 8.6/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Changed
| Confidentiality | High
| Integrity | None
| Availability  | None
|===

=== Impact

There is a bug in Wasmtime's implementation of it's pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance. The pooling instance allocator in Wasmtime works by preallocating virtual memory for a fixed number of instances to reside in and then new instantiations pick a slot to use. Most conventional modules additionally have an initial copy-on-write "heap image" which is mapped in Wasmtime into the linear memory slot. When a heap slot is deallocated Wasmtime resets all of its contents back to the initial state but it does not unmap the image in case the next instance is an instantiation of the same module.

The bug in Wasmtime occurs when a slot in the pooling allocator previously was used for a module with a heap image, meaning that its current state of memory contains the initial heap contents of that module. If the next instantiation within that slot does not itself contain a heap image then Wasmtime would leave the old heap image in place erroneously and continue with instantiation. This means that instantiations of modules without a heap image can see the initial heap image of the prior instantiation within that slot.

Heap images in Wasmtime are created by precomputing WebAssembly `data` segments into one large mapping to be placed into linear memory at a particular offset. Most modules produced by toolchains today will have a heap image and an initialization snapshot. Creating a module without a heap image would require a hand-crafted `*.wat` file or a specially crafted source program. This consequence means that this bug is highly unlikely to be accidentally triggered and would otherwise require an intentional trigger with a hand-crafted module.

One important part of this vulnerability is Wasmtime is highly likely to segfault when the slot is reused again with a module that itself has an initialization image. For example if module A has a heap initialization image and module B does not have a heap initialization image, then the following sequence of events could happen if they all are instantiated into the same instance slot:

* Module A is instantiated, and then deallocated. This leaves A's heap image in place, reset to its initial contents.
* Module B is instantiated and erroneously can see the initial heap contents of A. Module B is then deallocated and the entire heap is unmapped and reset back to zero.
* Module A is instantiated again, but the state tracking the slot did not account for module B so it thinks the module image is still mapped and proceeds with instantiation. Any action on A's part to access linear memory will then trap and if the host accesses A's memory it will segfault because the data that's supposed to be mapped is all unmapped.

Adding this all together this means that in practice modules must be deliberately crafted to not have an initial heap image to view the contents of a prior image. If this module is instantiated though then when the slot is reused the next, likely image-using, module will believe its memory is mapped when it isn't, causing the host to segfault on unmapped memory it believed was mapped. 

=== Patches

This bug has been patched and users should upgrade to Wasmtime 2.0.2.

=== Workarounds

Trigging this bug requires the pooling allocator to be configured and for copy-on-write heap images to also be enabled. Pooling allocation is not enabled by default but copy-on-write heap images are. Mitigations for this bug include:

* Disabling the pooling allocator - note that pooling allocation is not enabled by default in Wasmtime
* Disabling the `memory-init-cow` feature or with https://docs.rs/wasmtime/2.0.1/wasmtime/struct.Config.html#method.memory_init_cow[`Config::memory_init_cow`]

=== References

* https://docs.rs/wasmtime/2.0.1/wasmtime/struct.Config.html#method.allocation_strategy[`Config::allocation_strategy`] - configuration required to enable the pooling allocator.
* https://docs.rs/wasmtime/2.0.1/wasmtime/struct.Config.html#method.memory_init_cow[`Config::memory_init_cow`] - configuration required to enable or disable copy-on-write (this is enabled by default).
* https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/c1HBDDJwNPA[Mailing list announcement]
* https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0[Patch for `release-2.0.0` branch]
* https://github.com/bytecodealliance/wasmtime/commit/3535acbf3be032ef1ba0b469b8ab92538a8a18a6[Patch for `main`]

=== For more information

If you have any questions or comments about this advisory:

* Reach out to us on https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime[the Bytecode Alliance Zulip chat]
* Open an issue in https://github.com/bytecodealliance/wasmtime/[the bytecodealliance/wasmtime repository]



## end::22[]
## tag::23[]
== H-23 libp2p DoS vulnerability from lack of resource management
Tags: `runtime`, Weakness: {url-cwe}400.html[CWE-400], {url-cwe}770.html[CWE-770], CVE ID: {url-nist}CVE-2022-23486[CVE-2022-23486], GHSA ID: {url-ghsa}GHSA-jvgw-gccv-q5p8[GHSA-jvgw-gccv-q5p8]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L2748
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=2747..2751]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

=== Impact

An attacker node can cause a victim node to allocate a large number of small memory chunks, which can ultimately lead to the victim’s process running out of memory and thus getting killed by its operating system. When executed continuously, this can lead to a denial of service attack, especially relevant on a larger scale when run against more than one node of a libp2p based network.

=== Details

In the original version of the attack, the malicious node would continuously open new streams on a single connection using a stream multiplexer that doesn’t provide sufficient back pressure (mplex or yamux). While allocations per stream might be considered small, they multiply with the number of streams and connections. It is easy to defend against this one attack, e.g. by setting a strict per connection stream limit and connection limit. But there are other variations of this attack, e.g. causing memory allocations by sending partial payloads on various protocol levels, forcing the victim to buffer the partial payload for a period of time or by tricking the victim into pre-allocating buffers for messages which are never sent by the attacker.

=== Patches

Users are advised to upgrade to `libp2p` `v0.45.1` or above.

=== References
Please see our DoS Mitigation page for more information on how to incorporate mitigation strategies, monitor your application, and respond to attacks: https://docs.libp2p.io/reference/dos-mitigation/.

Please see the related disclosure for go-libp2p: https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw and js-libp2p: https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv

=== For more information
If you have any questions or comments about this advisory, please email us at security@libp2p.io.


## end::23[]
## tag::24[]
== H-24 Race Condition in tokio
Tags: `runtime`, Weakness: {url-cwe}362.html[CWE-362], CVE ID: {url-nist}CVE-2021-45710[CVE-2021-45710], GHSA ID: {url-ghsa}GHSA-fg7r-2g4j-5cgr[GHSA-fg7r-2g4j-5cgr]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L7837
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=7836..7840]
++++
----

=== CVSS Score: 8.1/10
.CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | High
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | High
| Integrity | High
| Availability  | High
|===

If a tokio::sync::oneshot channel is closed (via the oneshot::Receiver::close method), a data race may occur if the oneshot::Sender::send method is called while the corresponding oneshot::Receiver is awaited or calling try_recv.

When these methods are called concurrently on a closed channel, the two halves of the channel can concurrently access a shared memory location, resulting in a data race. This has been observed to cause memory corruption.

Note that the race only occurs when both halves of the channel are used after the Receiver half has called close. Code where close is not used, or where the Receiver is not awaited and try_recv is not called after calling close, is not affected.



## end::24[]
## tag::25[]
== H-25 webpki: CPU denial of service in certificate path building
Tags: `runtime`, Weakness: {url-cwe}400.html[CWE-400], GHSA ID: {url-ghsa}GHSA-8qv2-5vq6-g2g7[GHSA-8qv2-5vq6-g2g7]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L8805
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=8804..8808]
++++
----

=== CVSS Score: 7.5/10
.CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H
[%header]
|===
2+| CVSS base metrics
| Attack vector | Network
| Attack complexity | Low
| Privileges required | None
| User interaction | None
| Scope | Unchange
| Confidentiality | None
| Integrity | None
| Availability  | High
|===

When this crate is given a pathological certificate chain to validate, it will spend CPU time exponential with the number of candidate certificates at each step of path building.

Both TLS clients and TLS servers that accept client certificate are affected.

This was previously reported in https://github.com/briansmith/webpki/issues/69.

`rustls-webpki` is a fork of this crate which contains a fix for this issue and is actively maintained.

## end::25[]
## tag::26[]
== H-26 Multiple issues involving quote API in shlex
Tags: `runtime`, GHSA ID: {url-ghsa}GHSA-r7qv-8r2h-pg27[GHSA-r7qv-8r2h-pg27]

.File {url-repo}{url-blob}HalbornCTF_Rust_Substrate/Cargo.lock#L6680
[source,rust]
---- 
++++ <.>
include::{ctf-dir}HalbornCTF_Rust_Substrate/Cargo.lock[lines=6679..6683]
++++
----


=== Issue 1: Failure to quote characters

Affected versions of this crate allowed the bytes `{` and `\xa0` to appear
unquoted and unescaped in command arguments.

If the output of `quote` or `join` is passed to a shell, then what should be a
single command argument could be interpreted as multiple arguments.

This does not *directly* allow arbitrary command execution (you can't inject a
command substitution or similar).  But depending on the command you're running,
being able to inject multiple arguments where only one is expected could lead
to undesired consequences, potentially including arbitrary command execution.

The flaw was corrected in version 1.2.1 by escaping additional characters.
Updating to 1.3.0 is recommended, but 1.2.1 offers a more minimal fix if
desired.

Workaround: Check for the bytes `{` and `\xa0` in `quote`/`join` input or
output.

(Note: `{` is problematic because it is used for glob expansion.  `\xa0` is
problematic because it's treated as a word separator in [specific
environments][solved-xa0].)

=== Issue 2: Dangerous API w.r.t. nul bytes

Version 1.3.0 deprecates the `quote` and `join` APIs in favor of `try_quote`
and `try_join`, which behave the same except that they have `Result` return
type, returning `Err` if the input contains nul bytes.

Strings containing nul bytes generally cannot be used in Unix command arguments
or environment variables, and most shells cannot handle nul bytes even
internally.  If you try to pass one anyway, then the results might be
security-sensitive in uncommon scenarios.  [More details here.][nul-bytes]

Due to the low severity, the behavior of the original `quote` and `join` APIs
has not changed; they continue to allow nuls.

Workaround: Manually check for nul bytes in `quote`/`join` input or output.

=== Issue 3: Lack of documentation for interactive shell risks

The `quote` family of functions does not and cannot escape control characters.
With non-interactive shells this is perfectly safe, as control characters have
no special effect.  But if you writing directly to the standard input of an
interactive shell (or through a pty), then control characters [can cause
misbehavior including arbitrary command injection.][control-characters]

This is essentially unfixable, and has not been patched.  But as of version
1.3.0, documentation has been added.

Future versions of `shlex` may add API variants that avoid the issue at the
cost of reduced portability.

[solved-xa0]: https://docs.rs/shlex/latest/shlex/quoting_warning/index.html#solved-xa0
[nul-bytes]: https://docs.rs/shlex/latest/shlex/quoting_warning/index.html#nul-bytes
[control-characters]: https://docs.rs/shlex/latest/shlex/quoting_warning/index.html#control-characters-interactive-contexts-only

## end::26[]
